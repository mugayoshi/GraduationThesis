\section{提案}
本研究では，Android を標的にしたマルウェアの動的解析を行う．マルウェアにログコードを挿入させ，そのログを動的に得ることで解析を行う．エミュレータでは再現できないために解析できないことも，本提案を適用することで，実機でマルウェアを動かすため解析できるというメリットがある．\ref{overview} では，本提案の全体の流れを説明する．\ref{analysismethod} では，本提案の解析手順を，\ref{placeinsert} では，ログコードをどこに挿入するかについて説明する．

\subsection{概要}
\label{overview}
マルウェアを解析するためにメソッドの情報が必要である．メソッドの情報とは具体的にいうと，メソッド名，そのクラス名，引数の型名と値である．

本提案では，これらの情報を得るためにマルウェアのメソッドにログを出力させるコードを挿入する．\ref{analysismethod} では，どのようにコードを挿入するかについて説明する．

本提案では，まずマルウェアの APK ファイルを入手することから始まる．次に，APK ファイルから Java クラスファイルを取り出し，ログをターミナルに出力させるためのコードを挿入する．このログには，実行したメソッド名，そのメソッドの引数の型名とその値を出力させるようにする．コードを挿入するとは，マルウェアから取り出した Java クラスファイルを書き換えるということである．マルウェアにコードを挿入した後，書き換えた Java クラスファイルを DEX コードに変換し，classes.dex を作成する．classes.dex を作ったら，元の APK ファイルの中にあるオリジナルの classes.dex とコードが挿入されている新しい classes.dex を入れ替える．ログコードを挿入したマルウェアを Android 端末にインストールした後，DDMS (Dalvik Debug Monitor Server) というツールを用いることで，Android OS が出す多数のログの中からマルウェアが出したログを抜き取る．それぞれのログにはタグがある．図 \ref{examplelog} の 3 つめのログのタグは "UploadsManager" であることがわかる．Android のログのタグは自分自身で決めることができるので，このタグを使って，本提案によるマルウェアのログのみを得ることができる．マルウェアのログを得ることで，マルウェアが実行したメソッドとその情報がわかるので，そこからマルウェアの挙動を解析できる．

\begin{figure}[t]
\begin{center}
\includegraphics[scale=0.2]{androidlogexample.eps}
\end{center}
\caption{Android が出力するログの例}
\label{examplelog}
\end{figure}

\subsection{解析手順}
\label{analysismethod}
大まかな説明，

まず最初に，APK ファイルから Java クラスファイルを取り出す．\ref{andrapp} で述べたように，APK ファイルを解凍することで，classes.dex を得ることができる．classes.dex からJava クラスファイルを取り出すために，dex2jar \cite{d2jar} が提供する sh プログラム (d2j-dex2jar.sh)を用いる．これにより， DEX コードファイルを JAR ファイルに変換することができる．よって，APK ファイルを解凍して出てきた classes.dex から dex2jar を用いて 1 つの JAR ファイルを得ることができる．この JAR ファイルを解凍することで Android アプリの Java クラスファイルを得る．

マルウェアの Java クラスファイルを得た後は，これにログを出力するコードを挿入する．つまりマルウェアの Java クラスファイルを書き換える．本研究では，Java クラスファイルを書き換えるために Javassist \cite{javassist} という Java ライブラリを用いる．Javassist は Java バイトコードの知識があまりなくても バイトコード変換のための API を提供する Java ライブラリである．Java で実装したプログラムでマルウェアの Java クラスファイルを書き換える．実装したプログラムについては，\ref{sec:instrument} 章で詳しく説明する．

Java クラスファイル を書き換えた後は，classes.dex を作成する．classes.dex を作成するためには，複数のクラスファイルを JAR ファイルにまとめる必要がある．dex2jar で得た JAR ファイルを解凍した際に，ディレクトリがいくつも出てくる場合がある．その場合は，ディレクトリ毎に JAR ファイルにまとめ，ディレクトリに属していないクラスファイルだけで，ひとつの JAR ファイルにまとめる． そして，以下に示すコマンドで JAR ファイルから classes.dex を作成する．dx とは，Android SDK が提供する dx コマンドのことである．このコマンドにより，JAR ファイルから DEX コードの変換を行う．

\begin{itembox}[l]{JAR ファイルから classes.dex を作る dx コマンド}
	dx --dex --output="classes.dex" "direcA.jar" "direcB.jar" 
\end{itembox}

次に，新しく作成した classes.dex を APK ファイル内にあるオリジナルの classes.dex と入れ替え．端末にインストールできるように APK ファイルにサインを行う．先に述べたように，APK ファイルは ZIP 形式であるから， zip コマンドに -u オプションをつけることで，新しいファイルを古いものと入れ替えることができる．APK ファイルにサインするためには，dex2jar の中の d2j-apk-sign.sh を用いる．例えば，sampleApp.apk に対してこのプログラムを実行すると，sampleApp\_signed.apk のように別の新しい APK ファイルが生成される．そして，adb shell を使って，この APK ファイルを実機にインストールする．

マルウェアのインストール後，手動でそのマルウェアを起動し，DDMS に出力されるマルウェアのログをテキストファイルに保存する．Android OS が出力しているログは，ターミナルでも見ることができるが，細かい内部システムの状態などの情報が大量に出てくる．そのため，マルウェアが出しているログをそこから見つけることは困難である．DDMS では，指定したタグのみを出力することができる．マルウェアに挿入するコードには，タグを自分で指定しているため，DDMS にはマルウェアの実行ログのみを表示することができる．そして，表示されているログをテキストファイルとして保存する．

さらに，ログをより解析しやすくするために，このマルウェアのログのテキストファイルをクラス毎に分割する．なぜなら，そのままの状態では，複数のクラスのメソッドのログが混在していて，何が行われているか理解しにくいためだ．ログをパースするスクリプトを実装し，それを得られたテキストファイルに適用し，クラス毎に分割した．このスクリプトについては， \ref{sec:instrument} 章で詳しく説明する．

\subsection{ログコードの挿入箇所}
\label{placeinsert}
マルウェアの挙動を解析するためには，ログコードを適切な箇所へ挿入する必要がある．そこで本節では，マルウェアの Java クラスファイルへログコードを挿入する際に，どのような箇所へ挿入するか，どのような情報をログコードで出力させるかについて説明する．\ref{methodtop} では，メソッドの先頭へのコード挿入について，\ref{methodcalls} では，メソッド呼び出しの前後でのコード挿入について，なぜそこへ挿入するかという理由も含めて説明する．

\subsubsection{メソッドの先頭へのコードの挿入}
 \label{methodtop}
メソッドの先頭へログコードを挿入するのは，メソッドが実行された時に，そのログコードを確実に実行しそのログを出力させるためである．Javassist が提供する API では，メソッドの先頭か，最後にコードを挿入できる．メソッドの最後にコードを挿入してしまうと，メソッドが実行されたときに，そのコードが確実に実行されるかどうかは分からない．理由は主に ２ つ考えられる．1 つは，メソッドの途中で return 文が書かれている場合である．if 文の中で return 文が書かれていて，ある条件ではその if 文が実行されて，メソッドの最後まで到達せずに呼び出し元へ返ってしまい，メソッドの最後にあるログコードは実行されなくなってしまう．また，マルウェア作成者が解析者の混乱を誘うために，意図的にメソッドの途中で return 文を置いている可能性もある．もう一つの理由は，そのメソッドが途中で他のメソッドを呼び出してそのメソッドの最後まで到達しない場合だ．例えば メソッド A，B の最後にログコードを挿入し，メソッド A の中でメソッド B を呼びだすというケースを考える．そして，メソッド B の中でそのアプリが終了する関数が最後に呼ばれたとする．そうすると，メソッド A だけでなく，メソッド B のログコードも実行されなくなってしまう．なぜなら，メソッド B のログコードはアプリを終了させる関数の後に挿入されることから，このログコードは実行されないからだ．もし実行フローが最後まで到達して，ログコードが実行されたとしても，解析する際には時系列とは逆の順番でログが出力されるので紛らわしくなってしまうというデメリットもある．メソッドの先頭へログコードを挿入するイメージ図 \ref{insertbefore} を以下に示す．図 \ref{insertbefore} が示すように各メソッドのメソッド先頭，つまりそのメソッドが実行された場合，この挿入されたコードが一番最初に実行されるということになる．よって，メソッドの先頭にログコードを挿入すると，メソッド内の条件等にかかわらず，必ずそのログコードが実行されることになる．

\begin{figure}[t]
\begin{center}
\includegraphics[scale=0.5]{image2.eps}
\end{center}
\caption{メソッドの先頭へコードを挿入するイメージ図}
\label{insertbefore}
\end{figure}

メソッドの先頭に挿入するログコードではクラス名，メソッド名，そのメソッドの引数の情報を出力させる．メソッドの引数の情報とは，引数の型名とその引数の値である．なぜ引数の型名だけでなく，中身を出力させるかというと，引数の中身がわかるとマルウェアの挙動がより見えやすくなるからである．例えば，メソッド名が "getCode"，メソッドの引数の 1 つの型が String 型とわかっていたとする．しかし，これだけでは，String の中身がどんなものなのかよくわからない．なぜなら，String 型の変数はいろんな使われ方が考えられるからだ．型名だけで類推することはできても特定するのはとても困難である．この引数はサーバからのコマンドや，盗んだ端末についての情報の文字列かもしれない．そこで，引数の具体的な値が，URL のような文字列であることがわかると，この引数はコードを取ってくるアドレスということである確率がとても高いといえる．同様なことが int 型の場合も考えられる．もし int 型のメソッドの引数が携帯電話の番号（11 ケタで，090 や 080 で始まっている数字列）だった場合，そのマルウェアは感染した端末の電話番号を盗んでいたり，SMS をバックグラウンドで送信している可能性が出てくる．たとえメソッド名がマルウェア作成者により意図的に変えられていたとしても電話番号を引数にとっているということは端末の情報への不正なアクセスを明らかに示している．このようにメソッドの引数の値はマルウェアを解析するにあたって重要な要素であり，この情報によって解析がより行いやすくなる．

\subsubsection{メソッド呼び出しの前後でのコードの挿入}
\label{methodcalls}

マルウェアをより深く解析していくために，メソッド呼び出しの前後にログコードを挿入する．図 \ref{insertbetw} はメソッドの前後にコードを挿入するイメージ図である．methodA の中で，methodB, methodC が呼び出されるとする．この図が示すように，呼び出されるそれぞれのメソッドの前後にログコードを挿入する．マルウェアをより詳細に解析していくためには，\ref{methodtop} で述べた，メソッドの先頭へログコードの挿入は不十分である．なぜなら，全てのメソッドに適用することはできないためだ．適用できないメソッドは 2 種類ある．1 つは java.lang に属するクラスである．たとえば，String クラスのメソッドである，toString() の先頭にはログコードを挿入することはできない．Javassist の API では，JVM にすでにロードされているクラスのクラスファイルは書き換えることができないという制限がある．そのため，Java のプログラムが実行時（この場合，クラスファイルを書き換えようとしている時）には，JVM には java.lang.String クラスがロードされているため，Javassist は String  クラスのクラスファイルを書き換えることはできない．\ref{methodtop} の方法が適用できないもう一つのメソッドの種類は Android API である．Android API は Android システムの内部に組み込まれているため，Java クラスファイルとしては存在していない．Javassist は Android の内部に組み込まれているものを操作できないため，Javassist では，これらのメソッドの先頭にコードを挿入することはできない．しかし，メソッドの前後にログコードを挿入する場合は Javassist の異なる API を用いるため，この 2 種類のメソッドについてのログを出力することができる．つまり，あるメソッドの中で，  String クラスのメソッドや，Android API が実行されたということがわかるようになる．メソッド呼び出しの前後にログコードを挿入することで，より多くのメソッドについてのログが出せるようになり，あるメソッド内でどんなメソッドが実行されたかが明らかになる．

\begin{figure}[t]
\begin{center}
\includegraphics[scale=0.5]{image4.eps}
\end{center}
\caption{メソッドの前後にコードを挿入するイメージ図}
\label{insertbetw}
\end{figure}

\begin{figure}[t]
\begin{center}
\includegraphics[scale=0.5]{structure2.eps}
\end{center}
\caption{Android の内部構成}
\label{structure}
\end{figure}

呼び出されるメソッド呼び出しについてのログには，それ自身はもちろんのこと，呼び出し元のメソッドの情報も出力させる．呼び出し元のメソッドの情報はマルウェアの解析に必要である．なぜなら，マルウェアの解析を行うにあたり，どのメソッドがどこから呼び出されたかを知る必要があるからだ．どこから呼び出されたかがわからないと，ただそのメソッドが実行されたということしかログからは知り得ない．例えば，クラス A のメソッド mA とクラス C のメソッド mC の 2 つのメソッドからクラス B の mB が実行される場合を考える．もし，呼び出し元の情報がないと，クラス B の mB の実行ログを得ても，クラス A のメソッド mA からなのか，クラス C のメソッド mC から呼び出されているかがわからない．また，\ref{methodtop} の方法では，プログラムの実装の都合や Javassist のAPI の都合上，呼び出し元をログとして出力させることはできない．\ref{sec:instrument} 章で説明するように，メソッドの先頭に挿入するプログラムのアルゴリズムでは，呼び出し元の情報を得る機能を追加することはできないためだ．メソッドの前後にコードを挿入する，と先に書いたが，実装上はメソッド呼び出しの置き換えを行っている．この置換えの際に呼び出されるメソッドのオブジェクト(javassist.expr.MethodCall クラスのオブジェクト ) を得られる．MethodCall クラスのオブジェクトの情報から呼び出しているメソッド名，そのメソッドのクラス名を取得することができる．

